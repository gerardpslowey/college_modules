/* 1 - emptyBT */ 
/* the empty binary tree */
emptyBT(nil) :- bTree(nil).


/* 2 - bTree(N,T1,T2) */ 
/* true if N is the root with left subtree T1 and right subtree T2, where all the items in T1 <= N and all the items in T2 > N. */
bTree(nil).
bTree(bTree(_,T1,T2)) :- 
    bTree(T1),
    bTree(T2).


/* 3 - insert(I,T1,T2) */ 
/* is true if T2 is the binary tree resulting from I being inserted into binary tree T1. */
insert(I,nil,bTree(I,nil,nil)).
insert(I,bTree(N,T1,T2),bTree(N,L1,T2)) :-
    I < N, 
    insert(I,T1,L1).
insert(I,bTree(N,T1,T2),bTree(N,T1,L2)) :-
    I > N,
    insert(I,T2,L2).


/* 4 - preorder(T,L) */
/* is true if L is a list of nodes generated by a preorder traversal of the binary tree T. */
preorder(nil, []).
preorder(bTree(N,T1,T2), L):-
    preorder(T1,L1), 
    preorder(T2,L2), 
    append([N|L1],L2,L).


/* 5 - inorder(T,L) */
/* is true if L is a list of nodes generated by a inorder traversal of the binary tree T. */
inorder(nil, []).
inorder(bTree(N,T1,T2), L):-
    inorder(T1,L1), 
    inorder(T2,L2), 
    append(L1,[N|L2],L).


/* 6 - postorder(T,L) */
/* is true if L is a list of nodes generated by a postorder traversal of the binary tree T. */
postorder(nil, []).
postorder(bTree(N,T1,T2), L):-
    postorder(T1,L1), 
    postorder(T2,L2), 
    append(L1,L2,M1), 
    append(M1,[N],L).


/* 7 - search(T,I) */
/* is true if I is contained in the binary tree T. */
search(bTree(I,_,_), I).
search(bTree(N,T1,_), I) :-
    N >= I, 
    search(T1,I).
search(bTree(N,_,T2), I) :-
    I > N, 
    search(T2,I).


/* 8 - height(T,H) */
/* is true if H is the height of the binary tree T. An empty tree has height 0 and a tree with one item has height 1. */
height(nil, 0).
height(bTree(_,T1,T2), H) :-
    height(T1, H1),
    height(T2, H2),
    H is 1 + max(H1, H2).
